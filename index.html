<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>iwillnotblunder</title>
    <link rel="stylesheet" href="https://unpkg.com/@lichess-org/chessground/assets/chessground.base.css" />
    <link rel="stylesheet" href="https://unpkg.com/@lichess-org/chessground/assets/chessground.brown.css" />
    <link rel="stylesheet" href="https://unpkg.com/@lichess-org/chessground/assets/chessground.cburnett.css" />
    <style>
      :root {
        --bg: #0b0f17;
        --surface: #121826;
        --surface-2: #0f1523;
        --text: #e6ecff;
        --muted: #93a1b5;
        --primary: #4f8cff;
        --primary-600: #3a70d9;
        --ring: rgba(79, 140, 255, 0.5);
        --border: #1f2937;
        --badge: #1b2333;
      }
      * { box-sizing: border-box; }
      body { font-family: ui-sans-serif, system-ui, -apple-system; margin: 0; padding: 24px; background: var(--bg); color: var(--text); }
      .topbar { display:flex; align-items:center; justify-content: space-between; margin-bottom: 16px; }
      .brand { font-weight: 700; letter-spacing: 0.3px; }
      .lang-switch { display:flex; gap:8px; }
      .lang-switch button { padding: 6px 10px; border:1px solid var(--border); background: var(--surface-2); color: var(--text); border-radius: 8px; cursor: pointer; }
      .lang-switch button.active { border-color: var(--primary); outline: 2px solid var(--ring); }

      .container { display: grid; grid-template-columns: 520px 1fr; gap: 24px; }
      .card { background: var(--surface); border: 1px solid var(--border); border-radius: 14px; box-shadow: 0 6px 20px rgba(0,0,0,0.35); position: relative; }
      .board-wrap { position: relative; width: 500px; height: 500px; padding: 0; }
      /* 让棋盘卡片与棋盘内容同一定位上下文，阴影不影响内部测量 */
      .grid.card { padding: 10px; }
      .grid.card, .panel.card { overflow: visible; }
      .board { width: 500px; height: 500px; position: relative; border-radius: 10px; overflow: hidden; }
      .panel { padding: 16px; display: flex; flex-direction: column; gap: 12px; }
      .badges { display: flex; gap: 8px; flex-wrap: wrap; }
      .badge { background: var(--badge); border:1px solid var(--border); border-radius: 8px; padding: 4px 8px; font-size: 12px; color: var(--muted); }
      .legend { font-size: 12px; color: var(--muted); }
      .row { display:flex; gap:8px; align-items:center; flex-wrap: wrap; }
      textarea { width: 100%; height: 84px; font-family: ui-monospace, SFMono-Regular, Menlo, monospace; background: var(--surface-2); color: var(--text); border:1px solid var(--border); border-radius: 10px; padding: 10px; }
      button { padding: 10px 12px; border-radius: 10px; border: 1px solid var(--border); background: var(--surface-2); color: var(--text); cursor: pointer; transition: border-color .15s ease, transform .05s ease; }
      button:hover { border-color: var(--primary); }
      button:active { transform: translateY(1px); }
      .btn-primary { background: linear-gradient(180deg, var(--primary), var(--primary-600)); border-color: var(--primary-600); color: white; }
      .btn-outline { background: transparent; }
      .square-overlay { position:absolute; left:0; top:0; width:100%; height:100%; pointer-events:none; z-index: 1000; box-sizing: border-box; }
      .probe-cell { position:absolute; width:12.5%; height:12.5%; opacity:0; pointer-events:none; }
      .board .cg-wrap { position: absolute !important; inset: 0 !important; }
      /* 消除主题在容器与棋盘上的边框/内边距，确保覆盖层与棋盘同一参考系 */
      .board .cg-wrap { border: 0 !important; padding: 0 !important; margin: 0 !important; box-sizing: border-box; }
      .board .cg-board { position: absolute !important; inset: 0 !important; width: 100% !important; height: 100% !important; border: 0 !important; padding: 0 !important; margin: 0 !important; box-sizing: border-box; }
      /* 确保 cg-container 是定位上下文，使 overlay 绝对定位贴合其实际 496×496 尺寸 */
      .board cg-container { display: block; position: relative !important; width: 100% !important; height: 100% !important; border: 0 !important; padding: 0 !important; margin: 0 !important; box-sizing: border-box; }
      .overlay-cell { position:absolute; box-sizing:border-box; }
      .heat { background: rgba(255,0,0,var(--alpha)); }
      .heat-blue { background: rgba(0,120,255,var(--alpha)); }
      .grid { position:relative; }
      .square-overlay { transform: translateZ(0); }
    </style>
  </head>
  <body>
    <div class="topbar">
      <div class="brand">iwillnotblunder</div>
      <div class="lang-switch">
        <button id="lang-en" class="active" data-i18n="lang.en">EN</button>
        <button id="lang-zh" data-i18n="lang.zh">中文</button>
      </div>
    </div>
    <div class="container">
      <div class="grid card">
        <div class="board-wrap">
          <div id="board" class="board brown"></div>
          <div id="overlay" class="square-overlay"></div>
        </div>
      </div>
      <div class="panel card">
        <div class="row">
          <button id="btn-apply-fen" class="btn-primary" data-i18n="btn.applyFen">Apply FEN</button>
          <button id="btn-reset" data-i18n="btn.reset">Start position</button>
          <button id="btn-toggle" data-i18n="btn.toggle">Show/Hide overlay (A)</button>
          <button id="btn-opponent" data-i18n="btn.opp">Opponent only (O)</button>
          <button id="btn-mine" data-i18n="btn.mine">Mine only (M)</button>
          <button id="btn-clear" data-i18n="btn.clear">Hide (H)</button>
          <button id="btn-switch-side" data-i18n="btn.switchSide">Switch my side (White/Black)</button>
        </div>
        <textarea id="fen"></textarea>
        <div class="badges">
          <span class="badge" data-i18n="badge.shortcuts">Hotkeys: A show/hide (keep last side) / O opponent / M mine / H hide</span>
          <span class="badge" data-i18n="badge.drag">Drag or click to move; overlay updates in real time</span>
        </div>
        <div class="legend" data-i18n="legend">Red: opponent control; Blue: my control. Opacity scales linearly with count.</div>
      </div>
    </div>

    <script type="module">
      import { Chessground } from 'https://cdn.skypack.dev/@lichess-org/chessground';
      import { Chess } from 'https://esm.sh/chess.js@1.4.0';

      const el = document.getElementById('board');
      const overlay = document.getElementById('overlay');
      const overlayCells = [];
      const fenInput = document.getElementById('fen');

      const chess = new Chess();
      fenInput.value = chess.fen();

      let myColor = 'w'; // 'w' 我方为白；'b' 我方为黑
      // 覆盖层展示模式：同一时间只显示一方或隐藏
      // 'opp' | 'mine' | 'none'
      let currentMode = 'opp';
      let lastMode = 'opp'; // 记录最近的非 none 模式，便于 A 键/按钮切换显示/隐藏

      const ground = Chessground(el, {
        orientation: 'white',
        movable: { color: 'white', showDests: true, free: false, events: { after: onAfterMove } },
        premovable: { enabled: false },
        drawable: { enabled: false, visible: false },
      });

      // ===== 轻量 i18n（默认英文，支持中文；localStorage 持久化） =====
      const LOCALE_KEY = 'locale';
      const i18n = {
        en: {
          lang: { en: 'EN', zh: '中文' },
          btn: {
            applyFen: 'Apply FEN',
            reset: 'Start position',
            toggle: 'Show/Hide overlay (A)',
            opp: 'Opponent only (O)',
            mine: 'Mine only (M)',
            clear: 'Hide (H)',
            switchSide: 'Switch my side (White/Black)'
          },
          badge: {
            shortcuts: 'Hotkeys: A show/hide (keep last side) / O opponent / M mine / H hide',
            drag: 'Drag or click to move; overlay updates in real time'
          },
          legend: 'Red: opponent control; Blue: my control. Opacity scales linearly with count.'
        },
        zh: {
          lang: { en: 'EN', zh: '中文' },
          btn: {
            applyFen: '应用 FEN',
            reset: '起始局面',
            toggle: '显示/隐藏覆盖层 (A)',
            opp: '只看对方 (O)',
            mine: '只看己方 (M)',
            clear: '隐藏 (H)',
            switchSide: '切换我方(白/黑)'
          },
          badge: {
            shortcuts: '快捷键：A 显示/隐藏（保留最近选择） / O 只对方 / M 只己方 / H 隐藏',
            drag: '拖拽或点击走子也会实时更新覆盖层'
          },
          legend: '红色：对方控制强度；蓝色：己方控制强度。透明度按控制次数线性映射。'
        }
      };

      function getDictValue(dict, path) {
        const parts = path.split('.');
        let cur = dict;
        for (const p of parts) {
          if (cur && Object.prototype.hasOwnProperty.call(cur, p)) cur = cur[p];
          else return undefined;
        }
        return cur;
      }

      let currentLocale = localStorage.getItem(LOCALE_KEY) || 'en';
      function applyLocale(locale) {
        currentLocale = locale;
        localStorage.setItem(LOCALE_KEY, locale);
        const dict = i18n[locale] || i18n.en;
        document.querySelectorAll('[data-i18n]').forEach((el) => {
          const key = el.getAttribute('data-i18n');
          const val = getDictValue(dict, key);
          if (typeof val === 'string') el.textContent = val;
        });
        // 激活语言按钮样式
        document.getElementById('lang-en').classList.toggle('active', locale === 'en');
        document.getElementById('lang-zh').classList.toggle('active', locale === 'zh');
      }

      function ensureOverlayAttached() {
        const cgBoard = el.querySelector('.cg-board');
        if (cgBoard && overlay.parentElement !== cgBoard) {
          cgBoard.appendChild(overlay);
          // 覆盖层占满棋盘可见区域
          overlay.style.left = '0';
          overlay.style.top = '0';
          overlay.style.width = '100%';
          overlay.style.height = '100%';
          // 基于真实棋盘百分比分割，探测第一格尺寸，取整后用于像素化布局
          const probe = document.createElement('div');
          probe.className = 'probe-cell';
          overlay.appendChild(probe);
          // 下一帧读取尺寸并移除
          requestAnimationFrame(() => {
            const rect = probe.getBoundingClientRect();
            overlay.dataset.cellW = String(Math.floor(rect.width));
            overlay.dataset.cellH = String(Math.floor(rect.height));
            overlay.removeChild(probe);
            refreshOverlay();
          });
        }
      }
      ensureOverlayAttached();

      function onAfterMove(orig, dest) {
        const move = chess.move({ from: orig, to: dest, promotion: 'q' });
        if (!move) {
          ground.cancelMove();
          return;
        }
        ground.set({ fen: chess.fen(), lastMove: [orig, dest] });
        updateMovable();
        refreshOverlay();
      }

      // ===== 精确“攻击格”计算（不依赖合法走法；忽略钉住的抑制） =====
      const filesArr = ['a','b','c','d','e','f','g','h'];
      const ranksArr = ['1','2','3','4','5','6','7','8'];
      const inBounds = (f, r) => f >= 0 && f < 8 && r >= 0 && r < 8;
      const toSq = (f, r) => `${String.fromCharCode('a'.charCodeAt(0) + f)}${r + 1}`;
      const fromSq = (sq) => ({
        f: sq.charCodeAt(0) - 'a'.charCodeAt(0),
        r: parseInt(sq[1], 10) - 1,
      });

      function enumerateAttacksFor(square, piece) {
        const { f, r } = fromSq(square);
        const res = [];
        const color = piece.color; // 'w' | 'b'
        const type = piece.type;   // 'p','n','b','r','q','k'

        const pushIf = (nf, nr) => {
          if (!inBounds(nf, nr)) return false;
          const targetSq = toSq(nf, nr);
          res.push(targetSq);
          // For sliders, caller will decide whether to continue
          return !chess.get(targetSq);
        };

        if (type === 'p') {
          const dir = color === 'w' ? 1 : -1;
          const cand = [ [f - 1, r + dir], [f + 1, r + dir] ];
          for (const [nf, nr] of cand) if (inBounds(nf, nr)) res.push(toSq(nf, nr));
          return res;
        }

        if (type === 'n') {
          const d = [
            [-2, -1], [-2, 1], [-1, -2], [-1, 2],
            [1, -2], [1, 2], [2, -1], [2, 1],
          ];
          for (const [df, dr] of d) {
            const nf = f + df, nr = r + dr;
            if (inBounds(nf, nr)) res.push(toSq(nf, nr));
          }
          return res;
        }

        if (type === 'k') {
          const d = [
            [-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]
          ];
          for (const [df, dr] of d) {
            const nf = f + df, nr = r + dr;
            if (inBounds(nf, nr)) res.push(toSq(nf, nr));
          }
          return res;
        }

        // sliding pieces
        const dirs = [];
        if (type === 'b' || type === 'q') dirs.push([-1,-1],[-1,1],[1,-1],[1,1]);
        if (type === 'r' || type === 'q') dirs.push([-1,0],[1,0],[0,-1],[0,1]);
        for (const [df, dr] of dirs) {
          let nf = f + df, nr = r + dr;
          while (inBounds(nf, nr)) {
            const cont = pushIf(nf, nr);
            const target = toSq(nf, nr);
            if (chess.get(target)) break; // stop at first piece (friend/enemy)
            nf += df; nr += dr;
          }
        }
        return res;
      }

      function computeControl() {
        const size = 8;
        const white = Array.from({ length: size }, () => Array(size).fill(0));
        const black = Array.from({ length: size }, () => Array(size).fill(0));

        for (const f of filesArr) {
          for (const r of ranksArr) {
            const sq = `${f}${r}`;
            const piece = chess.get(sq);
            if (!piece) continue;
            const attacks = enumerateAttacksFor(sq, piece);
            for (const t of attacks) {
              const tf = t.charCodeAt(0) - 'a'.charCodeAt(0);
              const tr = parseInt(t[1], 10) - 1;
              if (piece.color === 'w') white[tr][tf] += 1;
              else black[tr][tf] += 1;
            }
          }
        }
        return { white, black };
      }

      function ensureOverlayCells() {
        if (overlay.childElementCount === 64 && overlayCells.length === 64) return;
        overlay.innerHTML = '';
        overlayCells.length = 0;
        for (let i = 0; i < 64; i++) {
          const cell = document.createElement('div');
          cell.className = 'overlay-cell';
          cell.style.pointerEvents = 'none';
          overlay.appendChild(cell);
          overlayCells.push(cell);
        }
      }

      function refreshOverlay(mode = currentMode) {
        currentMode = mode;
        ensureOverlayAttached();
        ensureOverlayCells();

        // 隐藏模式：全部隐藏并返回
        if (mode === 'none') {
          for (let i = 0; i < 64; i++) overlayCells[i].style.display = 'none';
          return;
        }

        const { white, black } = computeControl();
        const mineColor = myColor;
        const oppColor = mineColor === 'w' ? 'b' : 'w';

        const maxVal = 6;
        const isWhitePerspective = myColor === 'w';

        // 以像素对齐，避免百分比累计舍入误差
        // 为确保与 overlay 坐标系完全一致，这里直接以 overlay 的实际可见尺寸为准
        const cgBoard = el.querySelector('.cg-board');
        const rect = cgBoard ? cgBoard.getBoundingClientRect() : overlay.getBoundingClientRect();
        const W = rect.width;
        const H = rect.height;
        // 与棋盘保持同样的 1/8 分割（允许小数，确保与 62.5 等尺寸对齐）
        const cellW = W / 8;
        const cellH = H / 8;
        const x = Array.from({ length: 9 }, (_, i) => i * cellW);
        const y = Array.from({ length: 9 }, (_, i) => i * cellH);
        // 为防止 .card 的内边距或外环导致误差，强制 overlay 自身填满容器
        overlay.style.left = '0px';
        overlay.style.top = '0px';
        overlay.style.width = '100%';
        overlay.style.height = '100%';

        const showMineOnly = mode === 'mine';
        const showOppOnly = mode === 'opp';

        for (let r = 0; r < 8; r++) {
          for (let f = 0; f < 8; f++) {
            const wv = white[r][f];
            const bv = black[r][f];
            const mineV = mineColor === 'w' ? wv : bv;
            const oppV = oppColor === 'w' ? wv : bv;
            const col = isWhitePerspective ? f : 7 - f;
            const row = isWhitePerspective ? 7 - r : r;

            let alpha = 0;
            let className = '';
            if (showMineOnly && mineV > 0) {
              // 仅显示我方：不受对方控制强度影响
              alpha = Math.min(0.7, mineV / maxVal);
              className = 'heat-blue';
            } else if (showOppOnly && oppV > 0) {
              // 仅显示对方：不受我方控制强度影响
              alpha = Math.min(0.7, oppV / maxVal);
              className = 'heat';
            }
            const cell = overlayCells[row * 8 + col];
            cell.style.left = x[col] + 'px';
            cell.style.top = y[row] + 'px';
            // 使用 toFixed 防止长小数导致的累积渲染误差
            cell.style.width = (x[col + 1] - x[col]).toFixed(2) + 'px';
            cell.style.height = (y[row + 1] - y[row]).toFixed(2) + 'px';
            if (alpha > 0) {
              cell.className = 'overlay-cell ' + className;
              cell.style.setProperty('--alpha', alpha.toString());
              cell.style.display = 'block';
            } else {
              cell.style.display = 'none';
            }
          }
        }
      }

      document.getElementById('btn-apply-fen').onclick = () => {
        const val = fenInput.value.trim();
        try {
          chess.load(val);
          ground.set({ fen: chess.fen() });
          updateMovable();
          refreshOverlay();
        } catch (e) { alert('FEN 无效'); }
      };
      document.getElementById('btn-reset').onclick = () => {
        chess.reset();
        ground.set({ fen: chess.fen(), lastMove: undefined });
        updateMovable();
        refreshOverlay();
      };

      document.getElementById('btn-toggle').onclick = () => {
        const next = currentMode === 'none' ? lastMode : 'none';
        refreshOverlay(next);
      };
      document.getElementById('btn-opponent').onclick = () => { lastMode = 'opp'; refreshOverlay('opp'); };
      document.getElementById('btn-mine').onclick = () => { lastMode = 'mine'; refreshOverlay('mine'); };
      document.getElementById('btn-clear').onclick = () => refreshOverlay('none');

      window.addEventListener('keydown', (e) => {
        if (e.key === 'a' || e.key === 'A') {
          const next = currentMode === 'none' ? lastMode : 'none';
          refreshOverlay(next);
        } else if (e.key === 'o' || e.key === 'O') {
          lastMode = 'opp';
          refreshOverlay('opp');
        } else if (e.key === 'm' || e.key === 'M') {
          lastMode = 'mine';
          refreshOverlay('mine');
        } else if (e.key === 'h' || e.key === 'H') {
          refreshOverlay('none');
        }
      });

      // 切换“我方”颜色，同时切换棋盘朝向
      document.getElementById('btn-switch-side').onclick = () => {
        myColor = myColor === 'w' ? 'b' : 'w';
        ground.set({ orientation: myColor === 'w' ? 'white' : 'black' });
        refreshOverlay();
      };

      // 语言切换按钮
      document.getElementById('lang-en').onclick = () => applyLocale('en');
      document.getElementById('lang-zh').onclick = () => applyLocale('zh');

      // 处理窗口/容器尺寸变化时的像素重绘
      const ro = new ResizeObserver(() => refreshOverlay());
      ro.observe(document.querySelector('.board-wrap'));
      window.addEventListener('resize', () => refreshOverlay());

      function updateMovable() {
        const verbose = chess.moves({ verbose: true });
        const dests = new Map();
        for (const m of verbose) {
          if (!dests.has(m.from)) dests.set(m.from, []);
          dests.get(m.from).push(m.to);
        }
        // 允许点选双方棋子，但只有轮到的一方会有可走目的地
        ground.set({ movable: { color: 'both', dests, showDests: true, free: false } });
      }

      ground.set({ orientation: myColor === 'w' ? 'white' : 'black' });
      updateMovable();
      // 初始化语言与 UI
      applyLocale(currentLocale);
      refreshOverlay();
    </script>
  </body>
  </html>


