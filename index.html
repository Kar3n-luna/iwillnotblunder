<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>iwillnotblunder</title>
    <link rel="stylesheet" href="https://unpkg.com/@lichess-org/chessground/assets/chessground.base.css" />
    <link rel="stylesheet" href="https://unpkg.com/@lichess-org/chessground/assets/chessground.brown.css" />
    <link rel="stylesheet" href="https://unpkg.com/@lichess-org/chessground/assets/chessground.cburnett.css" />
    <style>
      :root {
        --bg: #0b0f17;
        --surface: #121826;
        --surface-2: #0f1523;
        --text: #e6ecff;
        --muted: #93a1b5;
        --primary: #4f8cff;
        --primary-600: #3a70d9;
        --ring: rgba(79, 140, 255, 0.5);
        --border: #1f2937;
        --badge: #1b2333;
      }
      * { box-sizing: border-box; }
      body { 
        font-family: ui-sans-serif, system-ui, -apple-system; 
        margin: 0; 
        padding: 16px; 
        background: var(--bg); 
        color: var(--text); 
        min-height: 100vh;
      }
      
      /* 移动端优化 */
      @media (max-width: 768px) {
        body { padding: 12px; }
      }
      
      .topbar { 
        display:flex; 
        align-items:center; 
        justify-content: space-between; 
        margin-bottom: 16px; 
        flex-wrap: wrap;
        gap: 12px;
      }
      .brand { font-weight: 700; letter-spacing: 0.3px; }
      .lang-switch { display:flex; gap:8px; }
      .lang-switch button { 
        padding: 6px 10px; 
        border:1px solid var(--border); 
        background: var(--surface-2); 
        color: var(--text); 
        border-radius: 8px; 
        cursor: pointer; 
        min-width: 44px; /* 触摸友好 */
      }
      .lang-switch button.active { border-color: var(--primary); outline: 2px solid var(--ring); }

      .container { 
        display: grid; 
        grid-template-columns: 520px 1fr; 
        gap: 24px; 
        max-width: 1200px;
        margin: 0 auto;
      }
      
      /* 移动端响应式布局 */
      @media (max-width: 1024px) {
        .container { 
          grid-template-columns: 1fr; 
          gap: 16px; 
        }
      }
      
      @media (max-width: 768px) {
        .container { 
          gap: 12px; 
        }
      }
      
      .card { 
        background: var(--surface); 
        border: 1px solid var(--border); 
        border-radius: 14px; 
        box-shadow: 0 6px 20px rgba(0,0,0,0.35); 
        position: relative; 
      }
      .board-wrap { 
        position: relative; 
        width: 500px; 
        height: 500px; 
        padding: 0; 
        margin: 0 auto;
      }
      
      /* 移动端棋盘自适应 */
      @media (max-width: 768px) {
        .board-wrap { 
          width: 100%; 
          max-width: 400px; 
          height: auto; 
          aspect-ratio: 1;
        }
      }
      
      @media (max-width: 480px) {
        .board-wrap { 
          max-width: 320px; 
        }
      }
      
      /* 让棋盘卡片与棋盘内容同一定位上下文，阴影不影响内部测量 */
      .grid.card { padding: 10px; }
      .grid.card, .panel.card { overflow: visible; }
      .board { 
        width: 100%; 
        height: 100%; 
        position: relative; 
        border-radius: 10px; 
        overflow: hidden; 
      }
      .panel { 
        padding: 16px; 
        display: flex; 
        flex-direction: column; 
        gap: 12px; 
      }
      
      @media (max-width: 768px) {
        .panel { 
          padding: 12px; 
          gap: 12px; 
        }
      }
      
      .badges { 
        display: flex; 
        gap: 8px; 
        flex-wrap: wrap; 
      }
      .badge { 
        background: var(--badge); 
        border:1px solid var(--border); 
        border-radius: 8px; 
        padding: 4px 8px; 
        font-size: 12px; 
        color: var(--muted); 
      }
      .legend { 
        font-size: 12px; 
        color: var(--muted); 
      }
      .row { 
        display:flex; 
        gap:8px; 
        align-items:center; 
        flex-wrap: wrap; 
      }
      
      @media (max-width: 768px) {
        .row { 
          gap: 6px; 
        }
      }
      
      textarea { 
        width: 100%; 
        height: 84px; 
        font-family: ui-monospace, SFMono-Regular, Menlo, monospace; 
        background: var(--surface-2); 
        color: var(--text); 
        border:1px solid var(--border); 
        border-radius: 10px; 
        padding: 10px; 
        resize: vertical;
        min-height: 60px;
      }
      
      @media (max-width: 768px) {
        textarea { 
          height: 60px; 
          min-height: 50px;
          font-size: 14px;
        }
      }
      
      button { 
        padding: 10px 12px; 
        border-radius: 10px; 
        border: 1px solid var(--border); 
        background: var(--surface-2); 
        color: var(--text); 
        cursor: pointer; 
        transition: border-color .15s ease, transform .05s ease; 
        font-size: 14px;
        min-height: 44px; /* 触摸友好 */
        white-space: nowrap;
      }
      
      @media (max-width: 768px) {
        button { 
          padding: 10px 8px; 
          font-size: 13px; 
          min-height: 44px;
        }
      }
      
      button:hover { border-color: var(--primary); }
      button:active { transform: translateY(1px); }
      .btn-primary { 
        background: linear-gradient(180deg, var(--primary), var(--primary-600)); 
        border-color: var(--primary-600); 
        color: white; 
      }
      .btn-outline { background: transparent; }
      .square-overlay { 
        position:absolute; 
        left:0; 
        top:0; 
        width:100%; 
        height:100%; 
        pointer-events:none; 
        z-index: 1000; 
        box-sizing: border-box; 
      }
      .probe-cell { 
        position:absolute; 
        width:12.5%; 
        height:12.5%; 
        opacity:0; 
        pointer-events:none; 
      }
      .board .cg-wrap { position: absolute !important; inset: 0 !important; }
      /* 消除主题在容器与棋盘上的边框/内边距，确保覆盖层与棋盘同一参考系 */
      .board .cg-wrap { border: 0 !important; padding: 0 !important; margin: 0 !important; box-sizing: border-box; }
      .board .cg-board { position: absolute !important; inset: 0 !important; width: 100% !important; height: 100% !important; border: 0 !important; padding: 0 !important; margin: 0 !important; box-sizing: border-box; }
      /* 确保 cg-container 是定位上下文，使 overlay 绝对定位贴合其实际 496×496 尺寸 */
      .board cg-container { display: block; position: relative !important; width: 100% !important; height: 100% !important; border: 0 !important; padding: 0 !important; margin: 0 !important; box-sizing: border-box; }
      .overlay-cell { position:absolute; box-sizing:border-box; }
      .heat { background: rgba(255,0,0,var(--alpha)); }
      .heat-blue { background: rgba(0,120,255,var(--alpha)); }
      .grid { position:relative; }
      .square-overlay { transform: translateZ(0); }
      
      /* 移动端按钮组优化 */
      @media (max-width: 768px) {
        .row {
          display: grid;
          grid-template-columns: repeat(2, 1fr);
          gap: 8px;
        }
        
        .row button {
          width: 100%;
          text-align: center;
          white-space: normal;
          word-break: break-word;
          line-height: 1.2;
          padding: 10px 6px;
        }
        
        /* 主要按钮独占一行 */
        .btn-primary {
          grid-column: 1 / -1;
        }
        
        /* 切换按钮独占一行 */
        #btn-switch-side {
          grid-column: 1 / -1;
        }
      }
      
      /* 超小屏幕按钮优化 */
      @media (max-width: 480px) {
        .row {
          grid-template-columns: 1fr;
          gap: 6px;
        }
        
        .row button {
          padding: 8px 4px;
          font-size: 12px;
        }
      }
      
      /* 移动端徽章优化 */
      @media (max-width: 768px) {
        .badge {
          font-size: 11px;
          padding: 3px 6px;
        }
      }
      
      /* 移动端语言切换优化 */
      @media (max-width: 480px) {
        .topbar {
          flex-direction: column;
          align-items: stretch;
        }
        
        .lang-switch {
          justify-content: center;
        }
      }
      
      /* 移动端额外优化 */
      @media (max-width: 768px) {
        /* 确保棋盘在移动端有足够的触摸区域 */
        .board .cg-wrap {
          touch-action: manipulation;
        }
        
        /* 确保文本在小屏幕上可读 */
        .legend {
          font-size: 11px;
          line-height: 1.4;
        }
        
        /* 优化徽章显示 */
        .badges {
          gap: 6px;
        }
        
        .badge {
          font-size: 10px;
          padding: 3px 6px;
          line-height: 1.3;
        }
      }
      
      /* 超小屏幕优化 */
      @media (max-width: 360px) {
        body {
          padding: 8px;
        }
        
        .board-wrap {
          max-width: 280px;
        }
        
        .row button {
          font-size: 12px;
          padding: 6px 8px;
        }
      }
    </style>
  </head>
  <body>
    <div class="topbar">
      <div class="brand">iwillnotblunder</div>
      <div class="lang-switch">
        <button id="lang-en" class="active" data-i18n="lang.en">EN</button>
        <button id="lang-zh" data-i18n="lang.zh">中文</button>
      </div>
    </div>
    <div class="container">
      <div class="grid card">
        <div class="board-wrap">
          <div id="board" class="board brown"></div>
          <div id="overlay" class="square-overlay"></div>
        </div>
      </div>
      <div class="panel card">
        <div class="row">
          <button id="btn-apply-fen" class="btn-primary" data-i18n="btn.applyFen">Apply FEN</button>
          <button id="btn-reset" data-i18n="btn.reset">Start position</button>
          <button id="btn-toggle" data-i18n="btn.toggle">Show/Hide overlay (A)</button>
          <button id="btn-opponent" data-i18n="btn.opp">Opponent only (O)</button>
          <button id="btn-mine" data-i18n="btn.mine">Mine only (M)</button>
          <button id="btn-clear" data-i18n="btn.clear">Hide (H)</button>
          <button id="btn-switch-side" data-i18n="btn.switchSide">Switch my side (White/Black)</button>
        </div>
        <textarea id="fen"></textarea>
        <div class="badges">
          <span class="badge" data-i18n="badge.shortcuts">Hotkeys: A show/hide (keep last side) / O opponent / M mine / H hide</span>
          <span class="badge" data-i18n="badge.drag">Drag or click to move; overlay updates in real time</span>
        </div>
        <div class="legend" data-i18n="legend">Red: opponent control; Blue: my control. Opacity scales linearly with count.</div>
      </div>
    </div>

    <script type="module">
      import { Chessground } from 'https://cdn.skypack.dev/@lichess-org/chessground';
      import { Chess } from 'https://esm.sh/chess.js@1.4.0';

      const el = document.getElementById('board');
      const overlay = document.getElementById('overlay');
      const overlayCells = [];
      const fenInput = document.getElementById('fen');

      const chess = new Chess();
      fenInput.value = chess.fen();

      let myColor = 'w'; // 'w' 我方为白；'b' 我方为黑
      // 覆盖层展示模式：同一时间只显示一方或隐藏
      // 'opp' | 'mine' | 'none'
      let currentMode = 'opp';
      let lastMode = 'opp'; // 记录最近的非 none 模式，便于 A 键/按钮切换显示/隐藏

      const ground = Chessground(el, {
        orientation: 'white',
        movable: { color: 'white', showDests: true, free: false, events: { after: onAfterMove } },
        premovable: { enabled: false },
        drawable: { enabled: false, visible: false },
        // 移动端优化：启用触摸事件
        touchMove: true,
        // 移动端优化：禁用拖拽预览（避免触摸冲突）
        dragEnabled: true,
      });

      // ===== 轻量 i18n（默认英文，支持中文；localStorage 持久化） =====
      const LOCALE_KEY = 'locale';
      const i18n = {
        en: {
          lang: { en: 'EN', zh: '中文' },
          btn: {
            applyFen: 'Apply FEN',
            reset: 'Start position',
            toggle: 'Show/Hide (A)',
            opp: 'Opponent (O)',
            mine: 'Mine (M)',
            clear: 'Hide (H)',
            switchSide: 'Switch side (W/B)'
          },
          badge: {
            shortcuts: 'Hotkeys: A show/hide (keep last side) / O opponent / M mine / H hide',
            drag: 'Drag or click to move; overlay updates in real time'
          },
          legend: 'Red: opponent control; Blue: my control. Opacity scales linearly with count.'
        },
        zh: {
          lang: { en: 'EN', zh: '中文' },
          btn: {
            applyFen: '应用 FEN',
            reset: '起始局面',
            toggle: '显示/隐藏 (A)',
            opp: '只看对方 (O)',
            mine: '只看己方 (M)',
            clear: '隐藏 (H)',
            switchSide: '切换我方(白/黑)'
          },
          badge: {
            shortcuts: '快捷键：A 显示/隐藏（保留最近选择） / O 只对方 / M 只己方 / H 隐藏',
            drag: '拖拽或点击走子也会实时更新覆盖层'
          },
          legend: '红色：对方控制强度；蓝色：己方控制强度。透明度按控制次数线性映射。'
        }
      };

      function getDictValue(dict, path) {
        const parts = path.split('.');
        let cur = dict;
        for (const p of parts) {
          if (cur && Object.prototype.hasOwnProperty.call(cur, p)) cur = cur[p];
          else return undefined;
        }
        return cur;
      }

      let currentLocale = localStorage.getItem(LOCALE_KEY) || 'en';
      function applyLocale(locale) {
        currentLocale = locale;
        localStorage.setItem(LOCALE_KEY, locale);
        const dict = i18n[locale] || i18n.en;
        document.querySelectorAll('[data-i18n]').forEach((el) => {
          const key = el.getAttribute('data-i18n');
          const val = getDictValue(dict, key);
          if (typeof val === 'string') el.textContent = val;
        });
        // 激活语言按钮样式
        document.getElementById('lang-en').classList.toggle('active', locale === 'en');
        document.getElementById('lang-zh').classList.toggle('active', locale === 'zh');
      }

      function ensureOverlayAttached() {
        const cgBoard = el.querySelector('.cg-board');
        if (cgBoard && overlay.parentElement !== cgBoard) {
          cgBoard.appendChild(overlay);
          // 覆盖层占满棋盘可见区域
          overlay.style.left = '0';
          overlay.style.top = '0';
          overlay.style.width = '100%';
          overlay.style.height = '100%';
          // 基于真实棋盘百分比分割，探测第一格尺寸，取整后用于像素化布局
          const probe = document.createElement('div');
          probe.className = 'probe-cell';
          overlay.appendChild(probe);
          // 下一帧读取尺寸并移除
          requestAnimationFrame(() => {
            const rect = probe.getBoundingClientRect();
            overlay.dataset.cellW = String(Math.floor(rect.width));
            overlay.dataset.cellH = String(Math.floor(rect.height));
            overlay.removeChild(probe);
            refreshOverlay();
          });
        }
      }
      
      // 移动端优化：确保棋盘在窗口大小变化时重新计算
      function handleResize() {
        // 延迟执行，确保DOM更新完成
        setTimeout(() => {
          ensureOverlayAttached();
          refreshOverlay();
        }, 100);
      }
      ensureOverlayAttached();

      function onAfterMove(orig, dest) {
        const move = chess.move({ from: orig, to: dest, promotion: 'q' });
        if (!move) {
          ground.cancelMove();
          return;
        }
        ground.set({ fen: chess.fen(), lastMove: [orig, dest] });
        updateMovable();
        refreshOverlay();
      }

      // ===== 精确“攻击格”计算（不依赖合法走法；忽略钉住的抑制） =====
      const filesArr = ['a','b','c','d','e','f','g','h'];
      const ranksArr = ['1','2','3','4','5','6','7','8'];
      const inBounds = (f, r) => f >= 0 && f < 8 && r >= 0 && r < 8;
      const toSq = (f, r) => `${String.fromCharCode('a'.charCodeAt(0) + f)}${r + 1}`;
      const fromSq = (sq) => ({
        f: sq.charCodeAt(0) - 'a'.charCodeAt(0),
        r: parseInt(sq[1], 10) - 1,
      });

      function enumerateAttacksFor(square, piece) {
        const { f, r } = fromSq(square);
        const res = [];
        const color = piece.color; // 'w' | 'b'
        const type = piece.type;   // 'p','n','b','r','q','k'

        const pushIf = (nf, nr) => {
          if (!inBounds(nf, nr)) return false;
          const targetSq = toSq(nf, nr);
          res.push(targetSq);
          // For sliders, caller will decide whether to continue
          return !chess.get(targetSq);
        };

        if (type === 'p') {
          const dir = color === 'w' ? 1 : -1;
          const cand = [ [f - 1, r + dir], [f + 1, r + dir] ];
          for (const [nf, nr] of cand) if (inBounds(nf, nr)) res.push(toSq(nf, nr));
          return res;
        }

        if (type === 'n') {
          const d = [
            [-2, -1], [-2, 1], [-1, -2], [-1, 2],
            [1, -2], [1, 2], [2, -1], [2, 1],
          ];
          for (const [df, dr] of d) {
            const nf = f + df, nr = r + dr;
            if (inBounds(nf, nr)) res.push(toSq(nf, nr));
          }
          return res;
        }

        if (type === 'k') {
          const d = [
            [-1,-1], [-1,0], [-1,1], [0,-1], [0,1], [1,-1], [1,0], [1,1]
          ];
          for (const [df, dr] of d) {
            const nf = f + df, nr = r + dr;
            if (inBounds(nf, nr)) res.push(toSq(nf, nr));
          }
          return res;
        }

        // sliding pieces
        const dirs = [];
        if (type === 'b' || type === 'q') dirs.push([-1,-1],[-1,1],[1,-1],[1,1]);
        if (type === 'r' || type === 'q') dirs.push([-1,0],[1,0],[0,-1],[0,1]);
        for (const [df, dr] of dirs) {
          let nf = f + df, nr = r + dr;
          while (inBounds(nf, nr)) {
            const cont = pushIf(nf, nr);
            const target = toSq(nf, nr);
            if (chess.get(target)) break; // stop at first piece (friend/enemy)
            nf += df; nr += dr;
          }
        }
        return res;
      }

      function computeControl() {
        const size = 8;
        const white = Array.from({ length: size }, () => Array(size).fill(0));
        const black = Array.from({ length: size }, () => Array(size).fill(0));

        for (const f of filesArr) {
          for (const r of ranksArr) {
            const sq = `${f}${r}`;
            const piece = chess.get(sq);
            if (!piece) continue;
            const attacks = enumerateAttacksFor(sq, piece);
            for (const t of attacks) {
              const tf = t.charCodeAt(0) - 'a'.charCodeAt(0);
              const tr = parseInt(t[1], 10) - 1;
              if (piece.color === 'w') white[tr][tf] += 1;
              else black[tr][tf] += 1;
            }
          }
        }
        return { white, black };
      }

      function ensureOverlayCells() {
        if (overlay.childElementCount === 64 && overlayCells.length === 64) return;
        overlay.innerHTML = '';
        overlayCells.length = 0;
        for (let i = 0; i < 64; i++) {
          const cell = document.createElement('div');
          cell.className = 'overlay-cell';
          cell.style.pointerEvents = 'none';
          overlay.appendChild(cell);
          overlayCells.push(cell);
        }
      }

      function refreshOverlay(mode = currentMode) {
        currentMode = mode;
        ensureOverlayAttached();
        ensureOverlayCells();

        // 隐藏模式：全部隐藏并返回
        if (mode === 'none') {
          for (let i = 0; i < 64; i++) overlayCells[i].style.display = 'none';
          return;
        }

        const { white, black } = computeControl();
        const mineColor = myColor;
        const oppColor = mineColor === 'w' ? 'b' : 'w';

        const maxVal = 6;
        const isWhitePerspective = myColor === 'w';

        // 以像素对齐，避免百分比累计舍入误差
        // 为确保与 overlay 坐标系完全一致，这里直接以 overlay 的实际可见尺寸为准
        const cgBoard = el.querySelector('.cg-board');
        const rect = cgBoard ? cgBoard.getBoundingClientRect() : overlay.getBoundingClientRect();
        const W = rect.width;
        const H = rect.height;
        // 与棋盘保持同样的 1/8 分割（允许小数，确保与 62.5 等尺寸对齐）
        const cellW = W / 8;
        const cellH = H / 8;
        const x = Array.from({ length: 9 }, (_, i) => i * cellW);
        const y = Array.from({ length: 9 }, (_, i) => i * cellH);
        // 为防止 .card 的内边距或外环导致误差，强制 overlay 自身填满容器
        overlay.style.left = '0px';
        overlay.style.top = '0px';
        overlay.style.width = '100%';
        overlay.style.height = '100%';

        const showMineOnly = mode === 'mine';
        const showOppOnly = mode === 'opp';

        for (let r = 0; r < 8; r++) {
          for (let f = 0; f < 8; f++) {
            const wv = white[r][f];
            const bv = black[r][f];
            const mineV = mineColor === 'w' ? wv : bv;
            const oppV = oppColor === 'w' ? wv : bv;
            const col = isWhitePerspective ? f : 7 - f;
            const row = isWhitePerspective ? 7 - r : r;

            let alpha = 0;
            let className = '';
            if (showMineOnly && mineV > 0) {
              // 仅显示我方：不受对方控制强度影响
              alpha = Math.min(0.7, mineV / maxVal);
              className = 'heat-blue';
            } else if (showOppOnly && oppV > 0) {
              // 仅显示对方：不受我方控制强度影响
              alpha = Math.min(0.7, oppV / maxVal);
              className = 'heat';
            }
            const cell = overlayCells[row * 8 + col];
            cell.style.left = x[col] + 'px';
            cell.style.top = y[row] + 'px';
            // 使用 toFixed 防止长小数导致的累积渲染误差
            cell.style.width = (x[col + 1] - x[col]).toFixed(2) + 'px';
            cell.style.height = (y[row + 1] - y[row]).toFixed(2) + 'px';
            if (alpha > 0) {
              cell.className = 'overlay-cell ' + className;
              cell.style.setProperty('--alpha', alpha.toString());
              cell.style.display = 'block';
            } else {
              cell.style.display = 'none';
            }
          }
        }
      }

      document.getElementById('btn-apply-fen').onclick = () => {
        const val = fenInput.value.trim();
        try {
          chess.load(val);
          ground.set({ fen: chess.fen() });
          updateMovable();
          refreshOverlay();
        } catch (e) { alert('FEN 无效'); }
      };
      document.getElementById('btn-reset').onclick = () => {
        chess.reset();
        ground.set({ fen: chess.fen(), lastMove: undefined });
        updateMovable();
        refreshOverlay();
      };

      document.getElementById('btn-toggle').onclick = () => {
        const next = currentMode === 'none' ? lastMode : 'none';
        refreshOverlay(next);
      };
      document.getElementById('btn-opponent').onclick = () => { lastMode = 'opp'; refreshOverlay('opp'); };
      document.getElementById('btn-mine').onclick = () => { lastMode = 'mine'; refreshOverlay('mine'); };
      document.getElementById('btn-clear').onclick = () => refreshOverlay('none');

      window.addEventListener('keydown', (e) => {
        if (e.key === 'a' || e.key === 'A') {
          const next = currentMode === 'none' ? lastMode : 'none';
          refreshOverlay(next);
        } else if (e.key === 'o' || e.key === 'O') {
          lastMode = 'opp';
          refreshOverlay('opp');
        } else if (e.key === 'm' || e.key === 'M') {
          lastMode = 'mine';
          refreshOverlay('mine');
        } else if (e.key === 'h' || e.key === 'H') {
          refreshOverlay('none');
        }
      });

      // 切换“我方”颜色，同时切换棋盘朝向
      document.getElementById('btn-switch-side').onclick = () => {
        myColor = myColor === 'w' ? 'b' : 'w';
        ground.set({ orientation: myColor === 'w' ? 'white' : 'black' });
        refreshOverlay();
      };

      // 语言切换按钮
      document.getElementById('lang-en').onclick = () => applyLocale('en');
      document.getElementById('lang-zh').onclick = () => applyLocale('zh');

      // 处理窗口/容器尺寸变化时的像素重绘
      const ro = new ResizeObserver(() => handleResize());
      ro.observe(document.querySelector('.board-wrap'));
      window.addEventListener('resize', () => handleResize());
      
      // 移动端优化：监听方向变化
      window.addEventListener('orientationchange', () => {
        setTimeout(() => handleResize(), 500);
      });

      function updateMovable() {
        const verbose = chess.moves({ verbose: true });
        const dests = new Map();
        for (const m of verbose) {
          if (!dests.has(m.from)) dests.set(m.from, []);
          dests.get(m.from).push(m.to);
        }
        // 允许点选双方棋子，但只有轮到的一方会有可走目的地
        ground.set({ movable: { color: 'both', dests, showDests: true, free: false } });
      }

      ground.set({ orientation: myColor === 'w' ? 'white' : 'black' });
      updateMovable();
      // 初始化语言与 UI
      applyLocale(currentLocale);
      refreshOverlay();
    </script>
  </body>
  </html>


